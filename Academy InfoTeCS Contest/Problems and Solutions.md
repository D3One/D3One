## **Windows CryptoAPI: Основы работы и вызовы реализации российской криптографии ГОСТ**

**Аннотация:** Данная статья рассматривает основы работы криптографического интерфейса операционных систем семейства Microsoft Windows – CryptoAPI. Подробно разбираются его ключевые функции и классы для работы с электронной подписью (ЭП). Основное внимание уделено фундаментальному различию между западными алгоритмами (RSA, ECC), встроенными в ОС, и российскими криптографическими стандартами ГОСТ. Статья объясняет, почему стандартный функционал Windows не подходит для задач, требующих соблюдения отечественных стандартов, и намечает пути создания совместимых реализаций.

**Ключевые слова:** Windows CryptoAPI, Cryptography, Электронная подпись, ЭЦП, ГОСТ Р 34.10-2012, ГОСТ Р 34.11-2012, RSA, ECC, Криптопровайдер, Криптографическая служба, C++, Кибербезопасность.

---

### **1. Введение**

Операционная система Windows исторически является доминирующей платформой в корпоративном секторе, включая государственные учреждения и финансовые организации. Безопасность данных в этой экосистеме во многом опирается на встроенный криптографический стек – **Windows CryptoAPI**. Этот набор функций предоставляет разработчикам абстракцию для выполнения таких задач, как шифрование, хеширование, создание и проверка электронных подписей, работа с сертификатами.

Однако глобализация криптографических стандартов сталкивается с требованиями национальной безопасности отдельных стран. В Российской Федерации таким требованием является использование алгоритмов, стандартизированных **ГОСТ**. Эти алгоритмы (такие как ГОСТ Р 34.10-2012 для ЭП и ГОСТ Р 34.11-2012 для хеширования) фундаментально отличаются от своих западных аналогов (RSA, ECDSA, SHA).

Цель данной статьи – разобрать архитектуру CryptoAPI, продемонстрировать ее использование на практических примерах и детально обосновать необходимость разработки дополнительных модулей (в виде криптопровайдеров) для полноценной работы с российскими ГОСТами в среде Windows.

### **2. Архитектура Windows CryptoAPI**

CryptoAPI не является монолитной библиотекой. Это многоуровневый интерфейс, который обеспечивает гибкость и возможность расширения.

**Ключевые концепции:**
1.  **Криптографический Поставщик Услуг (Cryptographic Service Provider, CSP):** Это основа модели. CSP – это независимая библиотека (DLL), которая реализует конкретные криптографические алгоритмы и функции. Windows поставляется с набором встроенных CSP (например, `Microsoft Enhanced RSA and AES Cryptographic Provider`). Сторонние разработчики могут создавать и регистрировать собственные CSP для добавления новых алгоритмов (например, ГОСТ). Именно на этом уровне происходит принципиальное разделение между стандартными и ГОСТ-алгоритмами.
2.  **Ключевые контейнеры:** Каждый CSP содержит контейнеры ключей. Контейнер – это логическая сущность, хранящая пару ключей (открытый и закрытый) и связанные с ними сертификаты. В рамках CSP, ориентированного на ГОСТ, будут храниться ключи, сгенерированные по ГОСТ Р 34.10.
3.  **Хэндлы (Handles):** CryptoAPI использует модель хэндлов для работы с объектами: хэндлы провайдера (`HCRYPTPROV`), хэндлы ключей (`HCRYPTKEY`), хэндлы хэшей (`HCRYPTHASH`). Это идиоматичный для WinAPI подход.

**Базовый рабочий процесс для работы с ЭП:**
1.  **Получение контекста провайдера:** `CryptAcquireContext`
2.  **Создание объекта хэша:** `CryptCreateHash`
3.  **Хеширование данных:** `CryptHashData`
4.  **Создание подписи:** `CryptSignHash`
5.  **Или верификация подписи:** `CryptVerifySignature`
6.  **Освобождение ресурсов:** `CryptDestroyHash`, `CryptReleaseContext`

### **3. Практические примеры работы с ЭП на C++ с использованием CryptoAPI**

Рассмотрим ключевые функции и их применение.

#### **Пример 1: Инициализация и получение контекста провайдера**

```cpp
#include <windows.h>
#include <wincrypt.h>
#pragma comment(lib, "crypt32.lib")

// ...
HCRYPTPROV hCryptProv = 0; // Хэндл криптопровайдера
LPCWSTR pszContainer = L"MyKeyContainer"; // Имя контейнера
LPCWSTR pszProvider = MS_ENHANCED_PROV; // Используем встроенный провайдер (RSA-based)

// Попытка получить контекст существующего контейнера
if (!CryptAcquireContext(&hCryptProv, pszContainer, pszProvider, PROV_RSA_FULL, 0)) {
    // Если контейнер не существует, создаем новый
    if (GetLastError() == NTE_BAD_KEYSET) {
        if (!CryptAcquireContext(&hCryptProv, pszContainer, pszProvider, PROV_RSA_FULL, CRYPT_NEWKEYSET)) {
            // Обработка ошибки создания нового контейнера
            DWORD dwErr = GetLastError();
            // ...
        }
    } else {
        // Обработка других ошибок
    }
}
// Теперь hCryptProv готов к использованию
```

**Комментарий:** Функция `CryptAcquireContext` – это точка входа. Флаг `PROV_RSA_FULL` указывает на тип провайдера (в данном случае, поддерживающий RSA). Для ГОСТа потребовался бы другой флаг и другой `pszProvider`, например, `"CRYPTO-PRO GOST R 34.10-2012 Cryptographic Service Provider"`, если бы соответствующий CSP был установлен в системе.

#### **Пример 2: Создание и верификация подписи (упрощенная схема)**

```cpp
// ДАННЫЙ ПРИМЕР РАБОТАЕТ ТОЛЬКО СО ВСТРОЕННЫМИ ПРОВАЙДЕРАМИ WINDOWS (RSA, DSA) И НЕ ПОДХОДИТ ДЛЯ ГОСТ.

// 1. Хеширование данных
HCRYPTHASH hHash = 0;
BYTE* pbData = (BYTE*)"Data to be signed"; // Данные для подписи
DWORD dwDataLen = strlen((char*)pbData) + 1;

if (!CryptCreateHash(hCryptProv, CALG_SHA256, 0, 0, &hHash)) {
    // Ошибка
}
if (!CryptHashData(hHash, pbData, dwDataLen, 0)) {
    // Ошибка
}

// 2. Подписание хэша
DWORD dwSigLen = 0;
// Узнаем размер подписи
if (!CryptSignHash(hHash, AT_KEYEXCHANGE, NULL, 0, NULL, &dwSigLen)) {
    // Ошибка
}
std::vector<BYTE> signature(dwSigLen);
// Непосредственно создание подписи
if (!CryptSignHash(hHash, AT_KEYEXCHANGE, NULL, 0, signature.data(), &dwSigLen)) {
    // Обработка ошибки
}
CryptDestroyHash(hHash);

// 3. ВЕРИФИКАЦИЯ ПОДПИСИ
// 3.1. Снова создаем хэш от исходных данных
HCRYPTHASH hHashToVerify = 0;
CryptCreateHash(hCryptProv, CALG_SHA256, 0, 0, &hHashToVerify);
CryptHashData(hHashToVerify, pbData, dwDataLen, 0);

// 3.2. Проверяем подпись
BOOL isVerified = CryptVerifySignature(hHashToVerify, signature.data(), dwSigLen, hPublicKey, NULL, 0);
// isVerified == TRUE, если подпись верна

CryptDestroyHash(hHashToVerify);
CryptReleaseContext(hCryptProv, 0);
```

**Комментарий:** В этом примере используется алгоритм `CALG_SHA256`. Для использования ГОСТ Р 34.11-2012 потребовался бы идентификатор `CALG_GR3411_2012_256` (или `-512`), который стандартным провайдером Microsoft не поддерживается. Вызов `CryptSignHash` внутри себя использует алгоритм подписи, привязанный к ключу в контейнере (например, RSA). Для подписи ГОСТ Р 34.10-2012 требуется CSP, который реализует эту функциональность.

#### **Пример 3: Работа с сертификатами и ключами**

```cpp
// Поиск сертификата в хранилище Windows
HCERTSTORE hSystemStore = CertOpenSystemStore(0, L"MY"); // Хранилище "Личное"
PCCERT_CONTEXT pCertContext = NULL;
// Ищем сертификат по субъекту
pCertContext = CertFindCertificateInStore(hSystemStore,
                                          X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                          0,
                                          CERT_FIND_SUBJECT_STR,
                                          L"Common Name", // Имя субъекта
                                          NULL);
if (pCertContext) {
    // Извлекаем открытый ключ из сертификата
    HCRYPTKEY hPublicKey = 0;
    if (CryptImportPublicKeyInfo(hCryptProv,
                                 X509_ASN_ENCODING,
                                 &(pCertContext->pCertInfo->SubjectPublicKeyInfo),
                                 &hPublicKey)) {
        // Ключ готов для верификации
    }
    CertFreeCertificateContext(pCertContext);
}
CertCloseStore(hSystemStore, 0);
```

### **4. Несовместимость миров: Западные алгоритмы vs. Российские ГОСТы**

Вот ключевые аспекты, которые делают «родную» криптографию Windows несовместимой с ГОСТ без дополнительных провайдеров:

| Аспект | Западные алгоритмы (RSA, ECC, SHA) | Российские ГОСТы (34.10-2012, 34.11-2012) | Проблема для Windows |
| :--- | :--- | :--- | :--- |
| ****Математическая основа**** | RSA: задача факторизации больших чисел. ECC: эллиптические кривые. | ГОСТ 34.10-2012: Эллиптические кривые, но над другими полями и с другими параметрами (например, часто используется кривая id-tc26-gost-3410-2012-256-paramSetA). | Алгоритмы完全不同不同 (совершенно разные). Встроенные в Windows функции `CryptSignHash` не знают математики ГОСТ. |
| ****Идентификаторы алгоритмов**** | `CALG_SHA1`, `CALG_SHA256`, `CALG_RSA_SIGN`, `CALG_ECDSA` | `CALG_GR3411_2012_256`, `CALG_GR3411_2012_512`, `CALG_GR3410_2012_256`, `CALG_GR3410_2012_512` | Эти идентификаторы (`CALG_*`) просто неизвестны стандартному CSP Microsoft. Их поддерживают только специализированные ГОСТ-провайдеры (КриптоПро, ViPNet). |
| ****Формат ключей и сертификатов**** | Сертификаты X.509v3. Ключи в форматах PKCS#1, PKCS#8. | Сертификаты X.509v3, но с особыми расширениями и алгоритмами (например, `gostR3410-2012`). Ключи имеют свой формат. | Стандартные функции Windows `CertFindCertificateInStore` могут найти такой сертификат, но функции `CryptImportKey` не смогут работать с ключом ГОСТ без поддержки со стороны CSP. |
| ****Политика и сертификация**** | Алгоритмы одобрены NIST (США). | Алгоритмы одобрены ФСБ и ФСТЭК России и обязательны к использованию в государственных информационных системах (ГИС). | Использование незасертифицированных алгоритмов (как RSA в ГИС) может быть прямым нарушением требований регуляторов. |

**Вывод:** Стандартный функционал CryptoAPI `user-mode` уровня **не подходит** для работы с ГОСТ, потому что он не содержит реализаций этих алгоритмов. Windows предоставляет лишь каркас (API), а конкретную реализацию должны поставлять сторонние CSP.

### **5. Путь к реализации: Разработка и интеграция ГОСТ-совместимого решения**

Чтобы ваше приложение на C++ работало с ЭП на ГОСТ в Windows, необходимо отказаться от идеи использования встроенного провайдера и пойти одним из двух путей:

**1. Использование готового коммерческого CSP:**
   *   **КриптоПро CSP:** Фактический отраслевой стандарт в России. Предоставляет полноценный CSP, который регистрируется в системе и начинает откликаться на стандартные вызовы CryptoAPI (`CryptAcquireContext`, `CryptSignHash`), но с идентификаторами алгоритмов ГОСТ.
   *   **Как это выглядит в коде:**
        ```cpp
        // Указываем имя провайдера КриптоПро
        LPCWSTR pszGostProvider = L"Crypto-Pro GOST R 34.10-2012 Cryptographic Service Provider";
        // Пытаемся получить контекст, используя провайдер КриптоПро
        if (CryptAcquireContext(&hCryptProv, L"MyGostContainer", pszGostProvider, PROV_GOST_2012_256, CRYPT_NEWKEYSET)) {
            // Теперь можно использовать функции CryptCreateHash с CALG_GR3411_2012_256
            // и CryptSignHash, который будет подписывать по ГОСТ Р 34.10-2012
        }
        ```
   *   **Плюсы:** Высокая скорость разработки, сертификация ФСБ, надежность.
   *   **Минусы:** Проприетарная лицензия, стоимость.

**2. Разработка собственного криптопровайдера или middleware-библиотеки:**
   *   Это сложная, но максимально гибкая задача. Требуется реализовать все функции криптопровайдера, которые будут вызываться из `Advapi32.dll`.
   *   **Архитектура:** Ваша DLL должна экспортировать функции `CPAcquireContext`, `CPSignHash`, `CPVerifySignature` и др., соответствующие интерфейсу `MS_DEF_PROV` (для legacy) или новому интерфейсу `CNG` (Cryptography API: Next Generation).
   *   **Криптографическая основа:** Внутри своих функций вы используете pure C++ реализации алгоритмов ГОСТ (например, из открытых библиотек like `libgost15` или собственной разработки) или даже низкоуровневый ассемблер для оптимизации критичных участков.
   *   **Примерная логика своей функции верификации:**
        ```cpp
        // Псевдокод вашей реализации CryptVerifySignature
        BOOL WINAPI CPVerifySignature(
            HCRYPTHASH hHash,      // Хэндл хэша (рассчитанного по ГОСТ 34.11)
            CONST BYTE *pbSignature,
            DWORD dwSigLen,
            HCRYPTKEY hPubKey,     // Ключ (в вашем формате)
            LPCWSTR szDescription,
            DWORD dwFlags)
        {
            // 1. Извлечь сырые данные хэша из объекта hHash
            BYTE hashValue[64];
            DWORD hashLen = 64;
            CPGetHashParam(hHash, HP_HASHVAL, hashValue, &hashLen, 0);

            // 2. Извлечь открытый ключ из объекта hPubKey
            GOST_PUBLIC_KEY pubKey;
            CPExportKey(hPubKey, 0, PUBLICKEYBLOB, 0, (BYTE*)&pubKey, sizeof(pubKey));

            // 3. Взять подпись (pbSignature) и преобразовать ее из формата ASN.1 DER
            // в чистые координаты R и S (если требуется).

            // 4. Реализовать алгоритм верификации ЭП по ГОСТ Р 34.10-2012,
            // используя открытый ключ pubKey, хэш hashValue и подпись.
            // ЭТО СЕРДЦЕВИНА - ЗДЕСЬ ВЫЗОВ ВАШЕЙ C++/ASM РЕАЛИЗАЦИИ ГОСТ.
            bool result = MyGost2012VerifyFunction(pubKey, hashValue, hashLen, pbSignature, dwSigLen);

            return result ? TRUE : FALSE;
        }
        ```
   *   **Плюсы:** Полная независимость, отсутствие лицензионных отчислений.
   *   **Минусы:** Чрезвычайно высокая сложность, длительный цикл разработки и тестирования, необходимость прохождения собственной процедуры сертификации в ФСБ для использования в ГИС.

### **6. Заключение**

Windows CryptoAPI предоставляет мощный и унифицированный каркас для интеграции криптографии в приложения. Однако его стандартная реализация ориентирована исключительно на западные алгоритмы, что делает его непригодным для задач, требующих соблюдения российских cryptographic standards like ГОСТ.

Разработка модуля верификации ЭП на ГОСТ для Windows – это нетривиальная задача, требующая глубокого понимания как самих алгоритмов ГОСТ, так и архитектуры криптопровайдеров Windows. Наиболее практичным путем является лицензирование и интеграция готового коммерческого CSP, такого как КриптоПро. Однако для образовательных целей, демонстрации глубокой экспертизы или создания абсолютно независимого решения возможна и оправдана разработка собственной реализации, либо в виде полноценного CSP, либо в виде отдельной middleware-библиотеки, реализующей криптографические примитивы поверх чистого C++ и ассемблера.

Таким образом, выбор подхода зависит от конкретных задач проекта: коммерческое использование и compliance с требованиями регуляторов или академические исследования и демонстрация технологического суверенитета.

---
**Об авторе:** Иван Пискунов, специалист по кибербезопасности, лектор университета ИГЛУ (МГЛУ). Материал подготовлен в образовательных целях.
